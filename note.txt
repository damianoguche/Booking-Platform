Client (Web / Mobile)
        |
        v
API Gateway (Express)
        |
------------------------------------------------
| Booking | Availability | Payment | Guest |
------------------------------------------------
        |
     Database
   (PostgreSQL)
        |
 External Services
 (Payment Gateway, Email, SMS)


booking-platform/
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app.js
‚îÇ   ‚îú‚îÄ‚îÄ server.js
‚îÇ   |
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ payment.js
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ modules/
|   |   |
‚îÇ   |   ‚îú‚îÄ‚îÄ admin/
‚îÇ   ‚îÇ   |   ‚îú‚îÄ‚îÄ admin.controller.js
‚îÇ   ‚îÇ   |   ‚îú‚îÄ‚îÄ admin.service.js
‚îÇ   ‚îÇ   |   ‚îú‚îÄ‚îÄ admin.routes.js
‚îÇ   ‚îÇ   |   ‚îî‚îÄ‚îÄ admin.metrics.js
|   |   |
‚îÇ   |   ‚îú‚îÄ‚îÄ reports/
‚îÇ   ‚îÇ   |   ‚îú‚îÄ‚îÄ report.controller.js
‚îÇ   ‚îÇ   |   ‚îú‚îÄ‚îÄ report.service.js
‚îÇ   ‚îÇ   |   ‚îî‚îÄ‚îÄ report.routes.js
|   |   |
|   |   |‚îÄ‚îÄ user/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.controller.js
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.service.js
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.routes.js
|   |   | 
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ availability/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ availability.controller.js
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ availability.service.js
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ availability.routes.js
‚îÇ   ‚îÇ   |
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ booking/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ booking.controller.js
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ booking.service.js
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ booking.routes.js
‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ payment/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ payment.controller.js
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ payment.service.js
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ payment.routes.js
‚îÇ   ‚îÇ   |
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ guest/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ guest.controller.js
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ guest.service.js
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ guest.routes.js
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ middlewares/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ error.js
‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ   |    ‚îî‚îÄ‚îÄ response.js
|   |
|   ‚îú‚îÄ‚îÄ sockets/
‚îÇ   |   ‚îî‚îÄ‚îÄ metrics.socket.js
‚îú‚îÄ‚îÄ prisma/
‚îÇ   ‚îî‚îÄ‚îÄ schema.prisma
|   |
‚îÇ   ‚îú‚îÄ‚îÄ sockets/
‚îÇ   |   ‚îî‚îÄ‚îÄ metrics.socket.js
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ .env

npx prisma init

Initialized Prisma in your project

  prisma/
    schema.prisma
  prisma.config.ts
  .gitignore

User
 ‚îú‚îÄ‚îÄ Guest role
 ‚îÇ    ‚îî‚îÄ‚îÄ Booking, Payments, Reviews
 ‚îÇ
 ‚îî‚îÄ‚îÄ Host role
      ‚îî‚îÄ‚îÄ Properties, Availability, Pricing, Earnings

Best Practice (Airbnb-style)
- Single user account
- Multiple roles per user
- Feature access based on role

### Features
Redis locking for double bookings
Admin analytics (charts, trends)
Data warehouse integration

The correct flow (conceptually)
- Create booking ‚Üí status = PENDING
- Process payment
- Confirm booking ‚Üí status = CONFIRMED
- Send notification

Write operations are existence checks
update() ‚Üí must exist
delete() ‚Üí must exist
updateMany() ‚Üí may not exist (returns count)
findUnique() ‚Üí read-only

Make Socket.IO available globally
app.set("io", io);

What this does:
Stores io inside the Express app instance
Later, anywhere you have access to req:

const io = req.app.get("io");
io.emit("event", payload);

Why this is powerful:
- You can now emit socket events from:
    . REST controllers
    . Services
    . Background jobs

Example:
exports.createOrder = (req, res) => {
  const io = req.app.get("io");
  io.emit("order_created", { id: 123 });
  res.json({ success: true });
};

This bridges HTTP APIs and real-time events

Start listening for connections:

server.listen(PORT, () => {
  console.log(`Server listening on port ${PORT}`);
});

What this does:
- Opens a TCP port
- Starts accepting:
   . HTTP requests (Express)
   . WebSocket connections (Socket.IO)

At this point your app can:
 - Serve REST APIs
 - Handle WebSocket events
 - Emit real-time updates

Client (Browser / Mobile)
        |
        |  HTTP / WebSocket
        v
+-------------------------+
|   Node.js HTTP Server   |
|-------------------------|
|  Express   | Socket.IO  |
|  (REST)    | (Realtime)|
+-------------------------+
. Express ‚Üí request/response
. Socket.IO ‚Üí events & streams
. Same port, same server

Event timeline: Correct flow after booking creation
Request ‚Üí Controller ‚Üí Service ‚Üí DB commit
                                ‚Üì
                       Push metrics (Socket.IO)
                                ‚Üì
                        HTTP Response

Proper implementation of admin.metrics
What NOT to do:
 - Don‚Äôt access DB directly from controller
 - Don‚Äôt create socket logic in controller
 - Don‚Äôt recompute metrics on every socket connection    


The Golden Rule for Stripe Webhooks
- Stripe webhook routes must NOT pass through express.json() or 
bodyParser.json()
- They must receive the raw body only.  


Your event is logged multiple times because:
- Stripe guarantees delivery by resending
- Stripe deliberately sends the same event multiple times until it 
is 100% sure your server received it.

Stripe Also Sends Multiple Related Events
- One payment can generate many events:
  - payment_intent.created
  - payment_intent.processing
  - payment_intent.succeeded
  - charge.succeeded
  - checkout.session.completed


Guest vs Host ‚Äî Key Differences
Guest (Traveler / Booker)

A guest is a user who consumes properties.
Typical abilities:
 - Search & view properties
 - Make bookings
 - Pay for stays
 - Leave reviews
 - Cancel bookings
 - Message hosts

Data owned
 . Bookings
 . Payments
 . Reviews
 . Preferences (dates, location, budget)

Guests do not own properties.

Host (Property Owner / Manager)
A host is a user who provides and manages properties.

Typical abilities:
 - Add properties
 - Upload photos
 - Set pricing & availability
 - Manage bookings
 - Approve / reject requests
 - Communicate with guests
 - View earnings & payouts
 - Handle cancellations & disputes

Data owned:
 - Properties
 - Availability calendars
 - Pricing rules
 - Payout accounts
 - Booking history for their properties
üëâ Hosts own or manage properties.

Best Practice (Airbnb-style)
- Single user account
- Multiple roles per user
- Feature access based on role

This avoids:
- Duplicate accounts
- Messy migrations later
- Permission nightmares

Best Practice: Even Stronger Atomicity (Database-Level)
For production booking systems, also add:
 - Unique Constraint (Postgres)

 CREATE UNIQUE INDEX unique_booking
 ON availability(property_id, date)
 WHERE status = 'BOOKED';

This guarantees:
 - Even if your code fails, DB prevents double-booking.
 - This is called defensive consistency.

TRANSACTION:
 A transaction is a group of database operations that are treated as 
 one unit of work:

 `Check availability
  Create booking
  Update calendar`

ATOMIC:
 Atomic means all or nothing.
 - Either everything succeeds ‚Üí changes are saved or anything 
 fails and everything is rolled back. No partial result is allowed.

Example:
 - If booking is created but date blocking fails:
üëâ Atomicity ensures both are undone.

Relationship: ACID
 - In databases, transactions follow ACID:
 | Letter | Meaning     |
| ------ | ----------- |
| A      | Atomicity   |
| C      | Consistency |
| I      | Isolation   |
| D      | Durability  |


The field - property Property @relation(...) does not create a column.
It is a Prisma-level relation helper. It lets you do:

await prisma.availability.findMany({
  include: {
    property: true
  }
});

So you get:

{
  id: "...",
  propertyId: "...",
  date: "...",
  status: "AVAILABLE",
  property: {
    id: "...",
    name: "Ocean View"
  }
}

Without this field, you‚Äôd only get propertyId.
| Field      | Purpose                               |
| ---------- | ------------------------------------- |
| propertyId | Stores the relationship in DB         |
| property   | Lets Prisma navigate the relationship |

DEFAULT AVAILABILITY AFTER CREATION
Each day is available by default means:
 - System auto-creates daily rows
 - All start as AVAILABLE
 - Booking flips them to BOOKED
 - Cancel flips back


 Two-Phase Booking (Industry Standard)
 This is how Airbnb, hotels, airlines work:

 BOOKED (temporary hold)
‚Üí PENDING booking
‚Üí CONFIRMED after payment

Later:
PENDING ‚Üí CONFIRMED
or
PENDING ‚Üí EXPIRED ‚Üí AVAILABLE

| Table        | Purpose               |
| ------------ | --------------------- |
| Booking      | Reservation record    |
| Availability | Locked calendar slots |

The Booking service owns:
| Responsibility  | Table                  |
| --------------- | ---------------------- |
| Create booking  | booking                |
| Cancel booking  | booking + availability |
| Expire booking  | booking + availability |
| Confirm booking | booking + availability |


Payment Confirmation
Proper Responsibility Split:
| Service         | Responsibility         |
| --------------- | ---------------------- |
| Booking Service | Owns booking lifecycle |
| Payment Service | Owns money + gateways  |
| Admin           | Monitoring / overrides |

Why NOT Only Booking?
Because Booking cannot know if payment succeeded.

Only:
- Paystack
- Stripe
- Flutterwave
know that.

Correct Flow (Industry Standard)
Here is the real-world flow:

User ‚Üí Create Booking (PENDING, expiresAt)
‚Üì
User ‚Üí Pay
‚Üì
Gateway ‚Üí Webhook ‚Üí Payment Service
‚Üì
Payment Service ‚Üí Verify ‚Üí Emit Event
‚Üì
Booking Service ‚Üí CONFIRM

Recommended Architecture:

Client
   ‚Üì
Booking Service  ‚Üê‚Üí  Payment Service
   ‚Üì                    ‚Üì
Availability         Payment Gateway
Booking NEVER talks to gateway directly.

Payment Confirmation Pattern:
Step 1 ‚Äî Booking Service Creates Pending Booking
Step 2 ‚Äî Client Pays (via Payment Service)
 - User is redirected to Paystack/Stripe.
 - Payment Service creates transaction.
 Step 3 ‚Äî Gateway Sends Webhook
  - POST /payments/webhook
Step 4 ‚Äî Payment Service Verifies
const verified = await verifyWithGateway(ref);
if (!verified) return;
 - Never trust raw webhook.
 Step 5 ‚Äî Payment Service Notifies Booking Service
 Via:
 - HTTP
 - Queue (RabbitMQ/Kafka)
 - Event Bus

Example HTTP:
POST /booking/confirm
{
  bookingId,
  transactionId
}

Step 6 ‚Äî Booking Confirms
Your function runs: confirmBooking(bookingId);
